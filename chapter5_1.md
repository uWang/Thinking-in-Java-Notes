### 5.6 成员初始化
- 未初始化的局部变量更有可能是程序员的疏忽，因此编译器不会为其添加默认值，强制要求程序员提供一个初始值。
- 如果是类的数据成员，编译器会自动为其赋初始值。

### 5.7 构造器初始化
- 无法阻止自动初始化的进行，他将在构造器被调用之前发生。

```java
public class Counter {
	int i;
	Counter(){ i = 7; }
}
```
那么i首先会被置0，然后变为7。即使是已经指定初值的变量，这种情况都是成立的。

- 在类的内部，**变量定义的先后顺序决定了初始化的顺序**。即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。
- 静态初始化只有在必要时刻才会进行。一旦被初始化后，就不会再次被初始化。
- 初始化的顺序是先静态对象，而后是“非静态”对象。
- 总结下对象的创建过程，假设有个名为Dog的类：
	1. 即使没有显式的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。
	2. 然后载入Dog.class（这将创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只有在Class对象首次加载的时候进行一次。
	3. 当用new Dog()创建对象时，首先将在堆上为Dog对象分配足够的存储空间。
	4. 这块存储空间会被清零，这就自动地将Dog对象中的所有属性设置成了默认值。
	5. 执行所有出现于字段定义处的初始化**动作**。
	6. 执行构造器。

### 5.8.1 可变参数列表
- 有了可变参数，就再也不用显示地编写数组语法了，编译器会为你自动填充数组。
- 可变参数常常至于参数列表的最后。
- 可变参数列表不依赖于自动包装机制，而实际使用的是基本类型。
- 可变参数列表可以和自动包装机制和谐共处。

### 5.9 枚举类型
- 枚举可以和switch进行搭配。