# 第5章  初始化与清理

---
### 5.2.2 涉及基本类型的重载
- 如果传入的数据类型小于方法中声明的形式参数类型，实际参数类型会被自动提升。char略有不同，如果无法找到恰好接收char参数的方法，就会把char直接提升至int型。
- 如果传入的实际参数较大，就必须通过强制类型转换，窄化转换。如果不这样做，编译器就会报错。

### 5.4 this关键字
- 在必要处使用this，不要放在一些没必要的地方。
- 在构造器中，如果为this添加了参数列表，那么就会去调用相应的构造器。
	- this只能用在构造函数中。
	- 只能用this调用一次构造函数，不能调用两次。
	- 必须写在构造函数第一行。

### 5.5 清理：终结处理和垃圾回收
- 如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。
- finalize()一个范例：由于程序员的疏忽，一本书未被签入，要是没有**finalize()来验证终结条件**，将很难发现这种缺陷。

```java
/**
 * @author wangzhiyuan
 */
class Book {
	boolean checkedOut = false;
	Book(boolean checkOut) {
		checkedOut = checkOut;
	}
	void checkIn() {
		checkedOut = false;
	}
	@Override
	protected void finalize() throws Throwable {
		if(checkedOut)
			System.out.println("Error: checked out");
		super.finalize();
	}
}
public class TerminationCondition {
	public static void main(String[] args) {
		Book novel = new Book(true);
		novel.checkIn(); // proper cleanup
		new Book(true); // forget to clean up
		// force garbage collection & finalization
		System.gc(); 
	}
}
/* Output:
 * Error：checked out
 */
```

### 5.5.4 垃圾回收器如何工作
- **引用计数**是一种简单但速度很慢的垃圾回收技术。每个对象都包含一个引用计数器，当有引用连接至对象时，引用计数加1。当引用离开作用域或被置为null时，引用计数减1。虽然管理引用计数的开销不大，但这项开销在整个生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间（但是，引用计数模式经常会在计数值变为0时立即释放对象）。  
缺陷：如果对象间存在循环引用，可能会出现“对象应该被回收，但引用技术却不为零”的情况。引用计数常被用来说明垃圾收集的工作方式，但似乎从未被应用于任何一种Java虚拟机实现中。
- 更快一点的模式，依据的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈和静态存储区之中的引用。  
从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。那些未被访问到的对象就会被回收。这就解决了“交互自引用的对象组”的问题，因为他根本不会被发现。
- 在这种方式下，Java虚拟机采用了一种自适应的垃圾回收技术。  一种做法叫：**停止-复制（stop-and-copy）**。先暂停程序的运行，然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的都是垃圾。当对象复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列。
- 当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正。位于堆或者静态存储区的引用可以直接修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想象成有一个表格，将旧地址映射至新地址）。
- 对于这种所谓的“复制式回收器”而言 ，效率会降低，这有两个原因：首先，得有两个堆，在两个分离的堆之间来回倒腾，从而维护比实际多一倍空间。
- 第二个原因在于复制。程序进入稳定状态后，可能只会产生少量垃圾，甚至没有垃圾。尽管如此，复制式回收器仍然会将所有内存自一处复制到另一处，这很浪费。为了避免这种情况，一些Java虚拟机会进行检查：要是没有产生新垃圾，就会转到另一种工作模式（即“自适应”）。这种模式称为**标记-清扫（mark-and-sweep）**，Sun公司早期版本的Java虚拟机使用了这种技术。对一般用途而言，“标记-清扫”方式速度相当慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾时，它的速度就很快了。
- “标记-清扫”所依据的思路同样是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会产生任何复制动作。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。
- “停止-复制”的意思是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会被暂停，同样“标记-清扫”工作也必须在程序暂停的情况下才能进行。
- 在Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大时，它会占用单独的块。严格来说，“停止-复制”要求在释放旧有对象前，必须先把所有存活对象从旧堆复制到新堆，这将导致大量内存复制行为。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里拷贝对象了。每个块都用相应的代数来记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器将对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作--大型对象仍然不会被复制（只是其代数会增加），内含小型对象的那些块则被复制并整理。Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记-清扫”方式；同样，Java虚拟机会跟踪“标记-清扫”的效果，要是堆空间出现很多碎片，就切换回“停止-复制”方式。这就是“自适应”技术。你可以给它一个啰嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。
- Java虚拟机中有许多附加技术用以提升速度。尤其是与加载器操作有关的，被称为**“即时”（Just-In-Time, JIT）编译器的技术**。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作）,程序运行速度因此得以提升。当需要装载某个类（通常是在为该类创建第一个对象）时，编译器会先找到其.class文件，然后将该类的字节码装入内存。此时，有两种方案可供选择。一种是就让即时编译器编译所有代码。但这种做法有两个缺陷：这种加载动作散落在整个程序生命周期内，累加起来要花更多时间;并且会增加可执行代码的长度（字节码要比即时编译器展开后的本地机器码小很多），这将导致页面调度，从而降低程序速度。另一种做法称为惰性评估（lazy evaluation），意思是即时编译器只在必要的时候才编译代码。这样，从不会被执行的代码也许就压根不会被JIT所编译。新版JDK中的**Java HotSpot**技术就采用了类似方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。
